// var, let, const, function등의 선언을 스코프의 선두에 옮긴 것처럼 동작하는 특성 -> 호이스팅
// 변수는 총 3단계에 걸쳐 생성이 이루어진다. 1. 선언 단계 2. 초기화 단계 3. 할당 단계

//var 경우의 호이스팅 (function level scope)
//var은 선언과 초기화 단계가 동시에 이루어지기 때문에 변수 선언문이 어디의 위치에 있든 참조가 가능
// 1번째 코드
//==============================================

// console.log(name) //undefined(빈값)

// var name
// console.log(name) //undefined(빈값)
// name = 'lim'
// console.log(name) //lim

//==============================================

// let 경우의 호이스팅 (block level scope)
// let, const의 경우 선언 단계만 이루어지고, 초기화 단계는 변수 선언문에 도달했을 때 실행이 된다.
// 선언 단계와 초기화 단계 사이를 일시적 사각지대(TDZ)라고 한다.
// 2번째 코드
//==============================================

// //console.log(foo) // ReferenceError
// let foo // 변수 선언문에서 초기화 단계가 실행된다.
// console.log(foo) // undefined

// foo = 1 // 할당문에서 할당 단계가 실행된다.
// console.log(foo) // 1

//==============================================

// 중괄호 내에 블록 레벨 스코프가 생김 -> 스코프가 생김에 따라 호이스팅 발생 지역변수 foo가 선언이 됨 -> 이후 console.log(foo)에서 에러가 발생
// 3번째 코드
//==============================================

// let foo = 1 // 전역 변수

// {
//   console.log(foo) // ReferenceError 발생
//   let foo = 2 // 지역 변수
// }

//==============================================

// 추가 내용 : const는 재할당이 불가능. 객체의 경우에도 "재할당"은 불가능하지만  객체의 내용에 대해서는 변경이 가능함
// 4번째 코드
//==============================================

// const obj = { foo: 123 }
// obj = { bar: 456 } // TypeError -> 재할당은 불가능

const user = { name: 'Lee' }

// 객체의 내용은 변경(추가, 삭제, 변경)할 수 있다.
user.name = 'Kim'
user.gender = '남' // 추가

console.log(user) // {name: 'Kim', gender: '남'}

//==============================================
